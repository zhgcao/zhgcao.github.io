<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="没有什么能够阻挡，你对自由的向往！">
<meta property="og:type" content="website">
<meta property="og:title" content="匿名">
<meta property="og:url" content="https://zhgcao.github.io/index.html">
<meta property="og:site_name" content="匿名">
<meta property="og:description" content="没有什么能够阻挡，你对自由的向往！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="匿名">
<meta name="twitter:description" content="没有什么能够阻挡，你对自由的向往！">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://zhgcao.github.io/"/>

  <title> 匿名 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">匿名</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">爱自由、爱爬墙</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/git-create-remote-server/" itemprop="url">
                  Git自建远程仓库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T10:34:23+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用Git做代码控制时，除了放在GitHub这类公开的远程仓库，还可以很方便的自己建个远程仓库玩。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>找一台Linux机器，以Ubuntu为例，先添加一个git用户，供其他电脑访问远程库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure></p>
<p>如果是个人使用或小范围团队使用，通过SSH来访问会比较简单，收集所有需要访问的用户的ssh pub key，写入 <code>/home/git/.ssh/authorized_keys</code>，一行一条。</p>
<p>为了安全，也可以限制 git 用户登录 shell，编辑 <code>/etc/passwd</code>，找到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>把 <code>/bin/bash</code> 修改为 <code>/usr/bin/git-shell</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>
<p>git-shell一登录就会立即退出。</p>
<h2 id="新建远程仓库"><a href="#新建远程仓库" class="headerlink" title="新建远程仓库"></a>新建远程仓库</h2><p>远程仓库通常只需要做版本控制，不需要在上面直接修改提交代码，因此可以创建一个裸仓库，裸仓库没有工作区。<br>找一个放仓库的目录，如 <code>/home/git</code>，在这个目录下执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure></p>
<p>sample可以根据实际修改为自己想要的名称，git远程仓库往往以<code>.git</code>为后缀，上面的命令会建立一个空的仓库，目录名为sample.git。</p>
<p>把目录的所有者改为git<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure></p>
<p>至此远程仓库就建好了，在其他电脑，可以直接clone这个仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@&lt;remote server ip&gt;:/home/git/sample</span><br></pre></td></tr></table></figure></p>
<h2 id="一个本地库关联多个远程库"><a href="#一个本地库关联多个远程库" class="headerlink" title="一个本地库关联多个远程库"></a>一个本地库关联多个远程库</h2><p>公司正式项目的远程仓库需要做每日构建，对提交的代码有一定的要求，必须要功能完备没有编译错误才能提交，同时还限制了在远程仓库上创建分支。如果有个功能需要多人来协作开发，就可以用多个远程库的方式，在功能还未开发完时在团队内同步代码。<br>自建的远程库可以克隆自项目原来的库，如执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --bare -b &lt;branch&gt; --depth 1 &lt;project url&gt; [&lt;<span class="built_in">local</span> dir&gt;]</span><br></pre></td></tr></table></figure></p>
<p>和上面新建一样，<code>--bare</code>表示这是一个没有工作区的裸仓库。<br>如果项目库有多个分支，<code>-b &lt;branch&gt;</code> 表示只克隆某个分支，不需要将全库克隆下来。<br><code>--depth 1</code> 表示是浅克隆，只克隆最新的变更记录，其他不克隆。<br><code>&lt;project url&gt;</code> 是项目远程仓库的地址，<code>&lt;local dir&gt;</code> 为本地目录，可选。</p>
<p>克隆后，同样把所有者改为git用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git &lt;<span class="built_in">local</span> dir&gt;</span><br></pre></td></tr></table></figure></p>
<p>团队成员，在自己机器的本地库上，添加新的远程库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin2 git@&lt;team server ip&gt;:/home/git/sample</span><br></pre></td></tr></table></figure></p>
<p>远程库的名称默认是origin，为了和原有的远程库区分开，这里把新增的远程库命名为origin2</p>
<p>添加后，这个本地库就关联了2个远程库，代码可以先提交到团队自己的远程库，其他人就能通过拉取这个远程仓库及时获取他人的开发内容，待功能全部完成后再一次性提交到项目正式的远程库。<br>从新建的远程库拉取和提交修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin2 master</span><br><span class="line">$ git push origin2 master</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/09/nginx-reverse-proxy-google/" itemprop="url">
                  利用Nginx反向代理谷歌
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-09T11:23:56+08:00" content="2016-06-09">
              2016-06-09
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从谷歌被墙，虽然在家可以翻墙访问，但在公司翻墙不方便，只能在网上找谷歌镜像站（镜像站是通俗叫法，更准确的叫法是反向代理）。但这些找来的镜像站往往不太稳定，经常过一段时间就不能访问甚至也会被墙，所以想着要搭个个人自用的反向代理。</p>
<h2 id="搭反向代理需要的条件"><a href="#搭反向代理需要的条件" class="headerlink" title="搭反向代理需要的条件"></a>搭反向代理需要的条件</h2><ul>
<li><p>一个墙外的VPS<br>对VPS的要求不高，搬瓦工128m内存的小机，搭建及使用均毫无压力。</p>
</li>
<li><p>一个域名<br>网上有很多地方可以申请免费的域名，比如<a href="http://www.freenom.com/" target="_blank" rel="external">Freenom</a>，可以免费申请.tk、.ml、.cf、.ga等后缀的顶级域名，最长一年免费，到期可以免费续期。</p>
</li>
<li><p>域名的SSL证书<br>其实反向代理本身是不需要SSL证书的，但如果没有证书只用http，仍然会被墙检测到搜索的内容，也就非常容易被拦截甚至被封IP，所以，反代谷歌最好有SSL证书，用https协议来访问。<br>网上能免费申请SSL证书的地方不多，推荐<a href="https://www.startssl.com/" target="_blank" rel="external">StartSSL</a>，也是最长一年免费，到期再免费续期。申请SSL证书的步骤比较麻烦，可以看看这个教程：<a href="http://www.freehao123.com/startssl-ssl-apache-ngnix/" target="_blank" rel="external">新StartSSL免费SSL证书申请使用</a>。</p>
</li>
</ul>
<h2 id="安装并编译Nginx"><a href="#安装并编译Nginx" class="headerlink" title="安装并编译Nginx"></a>安装并编译Nginx</h2><p>Nginx自身就支持反向代理功能，但为了更好的反代谷歌，还需要至少一个第三方模块，Nginx加入第三方模块相对有点麻烦，需要下载源码重新编译。<br>这次折腾编译Nginx，参考了些网上的教程，但没有完全按照教程，步骤稍有点多，主要想尽量保留原有发行版的功能，以备以后用Nginx做其他用途。</p>
<p>以下命令全是在Ubuntu上执行，CentOs的命令不一样，用户默认为root，非root用户很多命令需要加sudo。</p>
<p>先安装需要用到的一些包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get update</span></span><br><span class="line"><span class="comment"># apt-get install libpcre3 libpcre3-dev</span></span><br><span class="line"><span class="comment"># apt-get install zlib1g zlib1g-dev openssl libssl-dev</span></span><br><span class="line"><span class="comment"># apt-get install libxml2 libxml2-dev libxslt1-dev</span></span><br><span class="line"><span class="comment"># apt-get install libgd-dev libgeoip-dev</span></span><br><span class="line"><span class="comment"># apt-get install -y gcc g++ make automake</span></span><br></pre></td></tr></table></figure></p>
<p>安装Nginx的发行版<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get install nginx</span></span><br></pre></td></tr></table></figure></p>
<p>查看发行版的版本号和编译参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -V</span></span><br><span class="line">nginx version: nginx/1.9.3 (Ubuntu)</span><br><span class="line">built with OpenSSL 1.0.2d 9 Jul 2015</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --with-cc-opt=<span class="string">'-g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2'</span> --with-ld-opt=<span class="string">'-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now'</span> --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-ipv6 --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_addition_module --with-http_dav_module --with-http_geoip_module --with-http_gzip_static_module --with-http_image_filter_module --with-http_spdy_module --with-http_sub_module --with-http_xslt_module --with-mail --with-mail_ssl_module</span><br></pre></td></tr></table></figure></p>
<p>从上面的信息可以看到当前安装的是1.9.3版本，configure arguments后面跟的一长串是发行版的编译参数，很重要，后面需要用到。</p>
<p>找一个目录放源码，在这个目录里下载对应版本的Nginx源码并解压：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget http://nginx.org/download/nginx-1.9.3.tar.gz</span></span><br><span class="line"><span class="comment"># tar -zxvf nginx-1.9.3.tar.gz</span></span><br></pre></td></tr></table></figure></p>
<p>为了在反代时，更好的替换原网页中的信息，需要在编译时增加一个第三方模块：<a href="https://github.com/yaoweibin/ngx_http_substitutions_filter_module" target="_blank" rel="external">substitutions 扩展</a><br>下载 substitutions 的源码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module</span></span><br></pre></td></tr></table></figure></p>
<p>下载后，会在当前目录下有个 ngx_http_substitutions_filter_module 目录</p>
<p>另一个用于便捷配置反代Google的第三方模块：<a href="https://github.com/cuber/ngx_http_google_filter_module" target="_blank" rel="external">ngx_http_google_filter_module</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cuber/ngx_http_google_filter_module</span><br></pre></td></tr></table></figure></p>
<p>下载后，会在当前目录下有个 ngx_http_google_filter_module 目录，这个模块可选，增加后在Nginx配置文件中可以很简单的反代google</p>
<p>进入Nginx源码的目录，设置编译参数，其实就是在原发行版的编译参数后，增加两个<code>--add-module=../xxx</code>，把两个第三方模块包括进来。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd nginx-1.9.3</span></span><br><span class="line"><span class="comment"># ./configure \</span></span><br><span class="line">&gt; --with-cc-opt=<span class="string">'-g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2'</span> --with-ld-opt=<span class="string">'-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now'</span> --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-ipv6 --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_addition_module --with-http_dav_module --with-http_geoip_module --with-http_gzip_static_module --with-http_image_filter_module --with-http_spdy_module --with-http_sub_module --with-http_xslt_module --with-mail --with-mail_ssl_module \</span><br><span class="line">&gt; --add-module=../ngx_http_substitutions_filter_module \</span><br><span class="line">&gt; --add-module=../ngx_http_google_filter_module</span><br></pre></td></tr></table></figure></p>
<p>设置后，会开始检查这些编译参数和环境，如果上面少安装了某些包，或更新的版本需要其他的包，就会报错，如少安装了libgeoip-dev，会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure: error: the GeoIP module requires the GeoIP library.</span><br></pre></td></tr></table></figure></p>
<p>如果报了这类错误，可以Google一下错误信息，找到缺失的包并安装，然后再次执行 <code>./configure ...</code> 命令设置编译参数。</p>
<p>如果检查通过，最后会显示如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Configuration summary</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + using system OpenSSL library</span><br><span class="line">  + md5: using OpenSSL library</span><br><span class="line">  + sha1: using OpenSSL library</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: &quot;/usr/share/nginx&quot;</span><br><span class="line">  nginx binary file: &quot;/usr/share/nginx/sbin/nginx&quot;</span><br><span class="line">  nginx configuration prefix: &quot;/etc/nginx&quot;</span><br><span class="line">  nginx configuration file: &quot;/etc/nginx/nginx.conf&quot;</span><br><span class="line">  nginx pid file: &quot;/run/nginx.pid&quot;</span><br><span class="line">  nginx error log file: &quot;/var/log/nginx/error.log&quot;</span><br><span class="line">  nginx http access log file: &quot;/var/log/nginx/access.log&quot;</span><br><span class="line">  nginx http client request body temporary files: &quot;/var/lib/nginx/body&quot;</span><br><span class="line">  nginx http proxy temporary files: &quot;/var/lib/nginx/proxy&quot;</span><br><span class="line">  nginx http fastcgi temporary files: &quot;/var/lib/nginx/fastcgi&quot;</span><br><span class="line">  nginx http uwsgi temporary files: &quot;/var/lib/nginx/uwsgi&quot;</span><br><span class="line">  nginx http scgi temporary files: &quot;/var/lib/nginx/scgi&quot;</span><br></pre></td></tr></table></figure></p>
<p>然后编译Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make </span></span><br><span class="line"><span class="comment"># make install</span></span><br></pre></td></tr></table></figure></p>
<p>将编译后的文件替换到发行版的安装目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cp -rf objs/nginx /usr/sbin/nginx</span></span><br></pre></td></tr></table></figure></p>
<p>可以用如下命令来关闭/启动 Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl stop nginx</span></span><br><span class="line"><span class="comment"># systemctl start nginx</span></span><br></pre></td></tr></table></figure></p>
<p>用如下命令可以查看运行的状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl status nginx</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Nginx的设置"><a href="#Nginx的设置" class="headerlink" title="Nginx的设置"></a>Nginx的设置</h2><p>Nginx的配置文件是 <code>/etc/nginx/nginx.conf</code>，贴一下我反代Google的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># upstream配置google的ip，ip可以通过 nslookup www.google.com 命令获取，</span><br><span class="line"># 多运行几次nslookup会获取到多个IP，有助于避免触发google的防机器人检测。</span><br><span class="line">upstream www.google.com &#123;</span><br><span class="line">    server 172.217.0.4:443 weight=1;</span><br><span class="line">    server 172.217.1.36:443 weight=1;</span><br><span class="line">    server 216.58.193.196:443 weight=1;</span><br><span class="line">    server 216.58.216.4:443 weight=1;</span><br><span class="line">    server 216.58.216.36:443 weight=1;</span><br><span class="line">    server 216.58.219.36:443 weight=1;</span><br><span class="line">    server 74.125.25.99:443 weight=1;</span><br><span class="line">    server 74.125.25.103:443 weight=1;</span><br><span class="line">    server 74.125.25.104:443 weight=1;</span><br><span class="line">    server 74.125.25.105:443 weight=1;</span><br><span class="line">    server 74.125.25.106:443 weight=1;</span><br><span class="line">    server 74.125.25.147:443 weight=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 这里将http的访问强制跳转到https，&lt;domain.name&gt;改为自己的域名。</span><br><span class="line">server &#123; </span><br><span class="line">    listen 80;</span><br><span class="line">    server_name &lt;domain.name&gt;;</span><br><span class="line">    # http to https</span><br><span class="line">    location / &#123;</span><br><span class="line">          rewrite ^/(.*)$ https://&lt;domain.name&gt;$1 permanent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># https的设置</span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  &lt;domain.name&gt;;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    </span><br><span class="line">    # SSL证书的设置，&lt;path to ssl.xxx&gt;改为自己的证书路径</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &lt;path to ssl.crt&gt;;</span><br><span class="line">    ssl_certificate_key &lt;path to ssl.key&gt;;</span><br><span class="line"></span><br><span class="line">    # 防止网络爬虫</span><br><span class="line">    #forbid spider</span><br><span class="line">    if ($http_user_agent ~* &quot;qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo! Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot&quot;) </span><br><span class="line">    &#123; </span><br><span class="line">        return 403; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 禁止用其他域名或直接用IP访问，只允许指定的域名</span><br><span class="line">    #forbid illegal domain</span><br><span class="line">    if ( $host != &quot;&lt;domain.name&gt;&quot; ) &#123;</span><br><span class="line">        return 403; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log  off;</span><br><span class="line">    error_log   on;</span><br><span class="line">    error_log  /var/log/nginx/google-proxy-error.log;</span><br><span class="line">	</span><br><span class="line">    # 编译时加了 ngx_http_google_filter_module 模块，location的设置就非常简单</span><br><span class="line">    location / &#123;</span><br><span class="line">        google on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果编译时没有加 ngx_http_google_filter_module 模块，location的设置可以参考如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    proxy_cookie_domain google.com &lt;domain.name&gt;; </span><br><span class="line">    proxy_pass https://www.google.com;</span><br><span class="line">    proxy_connect_timeout 60s;</span><br><span class="line">    proxy_read_timeout 5400s;</span><br><span class="line">    proxy_send_timeout 5400s;</span><br><span class="line"></span><br><span class="line">    proxy_set_header Host &quot;www.google.com&quot;;</span><br><span class="line">    proxy_set_header User-Agent $http_user_agent;</span><br><span class="line">    proxy_set_header Referer https://www.google.com;</span><br><span class="line">    proxy_set_header Accept-Encoding &quot;&quot;;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr; </span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; </span><br><span class="line">    proxy_set_header X-Forwarded-Proto https;</span><br><span class="line">    proxy_set_header Accept-Language &quot;zh-CN&quot;;</span><br><span class="line">    proxy_set_header Cookie &quot;PREF=ID=047808f19f6de346:U=0f62f33dd8549d11:FF=2:LD=en-US:NW=1:TM=1325338577:LM=1332142444:GM=1:SG=2:S=rE0SyJh2W1IQ-Maw&quot;;</span><br><span class="line"></span><br><span class="line">    subs_filter https://www.google.com.hk &lt;domain.name&gt;;</span><br><span class="line">    subs_filter https://www.google.com &lt;domain.name&gt;;</span><br><span class="line">    #subs_filter_types text/css text/xml text/javascript;</span><br><span class="line"></span><br><span class="line">    sub_filter_once off; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改完配置文件后，可以用 <code>nginx -t</code> 检查配置文件是否正确：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure></p>
<p>看到上面的显示就表明设置正确。</p>
<p>配置文件修改后需要重启Nginx：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart nginx</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/04/64-27-year/" itemprop="url">
                  二十七年了
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-04T12:13:14+08:00" content="2016-06-04">
              2016-06-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从来不需要想起，永远也不会忘记！纪念那年，那些勇敢的人！</p>
<p><img src="/images/8964/tankman.jpg" alt="tankman" title="tankman"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/ubuntu-use-proxy/" itemprop="url">
                  Ubuntu设置使用代理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T14:33:03+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了方便测试一些命令和工具，在公司用VirtualBox安装了一个Ubuntu的Server版，Server版默认没有图像界面，跑起来对系统资源的占用比较少，很适合用于虚拟机，特别是在公司用了很多年的低配置电脑上。</p>
<p>在公司上网需要通过代理，这里简要介绍一下Ubuntu几个可能需要设置代理的地方。</p>
<h2 id="设置apt-conf"><a href="#设置apt-conf" class="headerlink" title="设置apt.conf"></a>设置apt.conf</h2><p>Ubuntu在安装时就会提示输入代理的设置，设置的代理保存在 /etc/apt/apt.conf 文件里，文件内容格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::Proxy &quot;http://&lt;proxy.server&gt;:&lt;port&gt;/&quot;;</span><br></pre></td></tr></table></figure></p>
<p>如果安装时没设置代理，或代理有变化，以后也可以编辑修改这个文件。</p>
<p>这样设置后，apt-get就可以正常使用了。</p>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>只设置apt.conf，wget或git等软件还是不能访问网络，这时可以再设置2个环境变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> http_proxy=http://&lt;proxy.server&gt;:&lt;port&gt;/</span><br><span class="line">$ <span class="built_in">export</span> https_proxy=http://&lt;proxy.server&gt;:&lt;port&gt;/</span><br></pre></td></tr></table></figure></p>
<p>或者将这2条命令添加到 ~/.bashrc 结尾。<br>如果访问的代理需要用户名和密码，上面的代理设置可以写成 <code>http://&lt;user&gt;:&lt;password&gt;@&lt;proxy.server&gt;:&lt;port&gt;/</code> 。<br>有了这两个环境变量，wget或git（通过http/https）等命令就可以正常访问网络了。</p>
<h2 id="wget的设置"><a href="#wget的设置" class="headerlink" title="wget的设置"></a>wget的设置</h2><p>对于wget，还可以编辑/etc/wgetrc，找到如下内容，去掉设置项前的<code>#</code>号并修改其中的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># You can set the default proxies for Wget to use for http, https, and ftp.</span><br><span class="line"># They will override the value in the environment.</span><br><span class="line">#https_proxy = http://proxy.yoyodyne.com:18023/</span><br><span class="line">#http_proxy = http://proxy.yoyodyne.com:18023/</span><br><span class="line">#ftp_proxy = http://proxy.yoyodyne.com:18023/</span><br><span class="line"></span><br><span class="line"># If you do not want to use proxy at all, set this to off.</span><br><span class="line">#use_proxy = on</span><br></pre></td></tr></table></figure></p>
<p>或者在主目录下新建一个文件 ~/.wgetrc，将上面那段内容复制过来并按实际修改。</p>
<p>如果想临时使用一个代理，不想修改配置文件或设置环境变量，可以在wget命令中增加 <code>-e &quot;xxx&quot;</code> 选项，这个选项是执行一个wgetrc格式的命令。<br>命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget <span class="_">-e</span> <span class="string">"use_proxy=on"</span> <span class="_">-e</span> <span class="string">"http_proxy=http://&lt;proxy.server&gt;:&lt;port&gt;/"</span> &lt;url&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Git的设置"><a href="#Git的设置" class="headerlink" title="Git的设置"></a>Git的设置</h2><p>Git支持Git、SSH、HTTP/HTTPS三种协议访问远程仓库，3钟协议的远程仓库地址格式不同，以 GitHub 为例：<br>Git协议：<code>git://github.com/...</code><br>SSH协议：<code>git@github.com:...</code><br>HTTP/HTTPS协议：<code>http://github.com/...</code> 或 <code>https://github.com/...</code></p>
<p>上面设置的环境变量，可以让Git使用HTTP/HTTPS协议通过代理访问远程仓库。</p>
<p>除了设环境变量，Git也可以通过如下命令设置http的代理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy http://&lt;user&gt;:&lt;password&gt;@&lt;proxy.server&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果要通过Git协议访问远程仓库，可以先安装一个软件 connect-proxy （其他发行版可能叫 proxy-connect）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install connect-proxy</span><br></pre></td></tr></table></figure></p>
<p>然后在 /usr/bin 下新建一个文件 httpproxywrapper ，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">connect -H &lt;proxy.server&gt;:&lt;port&gt; &quot;$@&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面的 -H 表示是Http代理，如果是socks代理，需要改为 -S。</p>
<p>给 httpproxywrapper 设置可执行权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod +x /usr/bin/httpproxywrapper</span><br></pre></td></tr></table></figure></p>
<p>然后设置 git 使用代理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.gitproxy /usr/bin/httpproxywrapper</span><br></pre></td></tr></table></figure></p>
<p>或设置环境变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GIT_PROXY_COMMAND=<span class="string">"/usr/bin/httpproxywrapper"</span></span><br></pre></td></tr></table></figure></p>
<p>这样设置，就可以用Git协议通过代理访问远程仓库了。</p>
<p>至于Git的SSH协议，网上找了几种方法，但经测试均无法通过http代理访问远程仓库，猜测可能和公司的代理设置有关，就不折腾了。</p>
<h2 id="Docker的设置"><a href="#Docker的设置" class="headerlink" title="Docker的设置"></a>Docker的设置</h2><p>Docker要使用代理，需要修改 <code>etc/default/docker</code> 这个文件，在其中增加如下几行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://&lt;proxy.server&gt;:&lt;port&gt;</span><br><span class="line">https_proxy=http://&lt;proxy.server&gt;:&lt;port&gt;</span><br><span class="line">export http_proxy https_proxy</span><br></pre></td></tr></table></figure></p>
<p>需要注意，原文档中有一行注释 <code>#export http_proxy=&quot;http://127.0.0.1:3128/&quot;</code>，但按照这样的格式直接写 <code>export http_proxy=http://&lt;proxy.server&gt;:&lt;port&gt;</code> 却不生效。</p>
<p>修改后，需要重启Docker才能使设置生效：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<p>用以下命令查看设置是否成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker info</span><br></pre></td></tr></table></figure></p>
<p>在返回信息中看到有以下两行就表明OK了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Http Proxy: http://&lt;proxy.server&gt;:&lt;port&gt;</span><br><span class="line">Https Proxy: http://&lt;proxy.server&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/01/find-google-ip-ranges/" itemprop="url">
                  如何查找Google的IP地址段
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-01T16:20:09+08:00" content="2016-06-01">
              2016-06-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般查找域名对应的IP，可以用这个命令 <code>nslookup &lt;域名&gt;</code>，但这样找，返回的ip比较少，今天看到一条命令，可以批量查找Google当前的IP范围。</p>
<p>命令及返回的结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nslookup -q=TXT _netblocks.google.com 8.8.8.8</span></span><br><span class="line">Server:         8.8.8.8</span><br><span class="line">Address:        8.8.8.8<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">_netblocks.google.com   text = <span class="string">"v=spf1 ip4:64.18.0.0/20 ip4:64.233.160.0/19 ip4:66.102.0.0/20 ip4:66.249.80.0/20 ip4:72.14.192.0/18 ip4:74.125.0.0/16 ip4:108.177.8.0/21 ip4:173.194.0.0/16 ip4:207.126.144.0/20 ip4:209.85.128.0/17 ip4:216.58.192.0/19 ip4:216.239.32.0/19 ~all"</span></span><br><span class="line"></span><br><span class="line">Authoritative answers can be found from:</span><br></pre></td></tr></table></figure></p>
<p>这条命令是从谷歌的DNS服务器（8.8.8.8），获取很多的IP地址段。每个地址段格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">216.239.32.0/19</span><br></pre></td></tr></table></figure></p>
<p>这是一个CIDR（无类别域间路由，Classless Inter-Domain Routing），前面的216.239.32.0是起始地址，后面的/19表示掩码的位数，这里具体的掩码是255.255.224.0，在这个掩码范围内的都是Google的IP，总计8190个。掩码位数越小，表示IP地址段的范围越大。上面查到的这些地址段表示的IP，全部加起来大概有二十多万个。</p>
<p>要根据CIDR计算地址范围可以<a href="http://www.aboutmyip.com/AboutMyXApp/SubnetCalculator.jsp?ipAddress=216.239.32.0&amp;cidr=19" target="_blank" rel="external">点这里</a>。</p>
<p>另外，VPS上安装的精简版Ubuntu，默认并没有安装nslookup，可以执行以下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get install dnsutils</span></span><br></pre></td></tr></table></figure></p>
<p>Centos安装nslookup的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install bind-utils</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/30/google-search-skill/" itemprop="url">
                  Google常用搜索技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-30T10:24:20+08:00" content="2016-05-30">
              2016-05-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Google是个人最常用的搜索引擎，没有之一，这里简单整理记录一下常用的一些Google搜索技巧，用好了，在搜索时能起到事半功倍的效果。</p>
<h2 id="或操作"><a href="#或操作" class="headerlink" title="或操作"></a>或操作</h2><p>一般搜索时，如果输入多个词，默认是与的关系，如输入词1和词2，即搜索同时包含词1和词2的网页，如果想搜包含词1 <strong>或</strong>包含词2 <strong>或</strong>同时都包含的网页，可以使用大写的 <code>OR</code>（不能用小写）。</p>
<p>举例：电影《肖申克的救赎》在台湾的翻译是《刺激1995》，如搜索关于这个电影的相关内容，搜索条件可以输入 <code>肖申克的救赎 OR 刺激1995</code>，可以把相关的内容一次全搜索出来。</p>
<h2 id="减号"><a href="#减号" class="headerlink" title="减号"></a>减号</h2><p>在搜索时，如果想排除某些内容，可以使英文字符 <code>-</code> 号。</p>
<p>举例：如搜索佛教中关于天龙八部的信息，想要排除金庸那本著名的同名小说，搜索条件可以输入 <code>天龙八部 佛教 -金庸</code>。</p>
<h2 id="星号或问号"><a href="#星号或问号" class="headerlink" title="星号或问号"></a>星号或问号</h2><p>有时记不清某个词或句子中的部分内容，或想模糊查询，可以在查询时使用通配符 <code>*</code> 或 <code>?</code>。</p>
<p>举例：如搜索<code>反向*理</code>，可以匹配“反向代理”、“反向D理”、“反向代-理”等内容</p>
<h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>正常搜索时，Google会试图找出含有全部搜索内容的网页，但对内容的次序并不关心，如果想要精确定位，可以将内容用双引号括起来。</p>
<p>举例：如搜索<code>&quot;postgresql教程&quot;</code>，得到的结果会明显少于<code>postgresql教程</code>。</p>
<h2 id="site"><a href="#site" class="headerlink" title="site"></a>site</h2><p>想让搜索限定在某个网站内，可以使用<code>site:xxxxx</code></p>
<p>举例：如只想在v2ex里搜索FinalSpeed相关的内容，搜索条件可以输入 <code>finalspeed site:v2ex.com</code><br>注意：site后的冒号是英文字符，且冒号后不能跟空格。网址中不需要有www、http、/等字符。</p>
<h2 id="filetype"><a href="#filetype" class="headerlink" title="filetype"></a>filetype</h2><p>如果要找一些文档资料，想指定某个文档类型，可以用<code>filetype:xxx</code>，而且Google支持直接搜索PDF、DOC等文件。</p>
<p>举例：如搜索关于PostgreSQL的相关PDF资料，搜索条件可以输入 <code>postgresql filetype:pdf</code></p>
<h2 id="intitle-和-allintitle"><a href="#intitle-和-allintitle" class="headerlink" title="intitle 和 allintitle"></a>intitle 和 allintitle</h2><p>有时只想要在网页的标题中搜索某些内容，可以用intitle 或 allintitle</p>
<p>举例：如在标题中搜索“postgresql 教程”，可以用以下用法：<code>intitle:postgresql 教程</code>，或<code>allintitle:postgresql 教程</code>，后一种写法等同于<code>intitle:postgresql intitle:教程</code></p>
<h2 id="intext-和-allintext"><a href="#intext-和-allintext" class="headerlink" title="intext 和 allintext"></a>intext 和 allintext</h2><p>这两个是在正文中搜索，用法类似intitle 和 allintitle。</p>
<h2 id="inurl-和-allinurl"><a href="#inurl-和-allinurl" class="headerlink" title="inurl 和 allinurl"></a>inurl 和 allinurl</h2><p>这两条命令是在网页地址中搜索，用法类似intitle 和 allintitle。</p>
<p>最后说一句：珍爱生命，远离百度。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/26/ubuntu-install-net-speeder/" itemprop="url">
                  Ubuntu安装net-speeder
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-26T08:37:10+08:00" content="2016-05-26">
              2016-05-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前个人最主要的科学上网工具，就是部署在搬瓦工上的Shadowsocks了，一直能稳定使用，唯一的缺点是速度不够快，看youtube时经常需要中断缓冲一会，不是很爽。</p>
<p>最近把搬瓦工上的系统更换了一下，重装了Shadowsocks，顺便研究了一下如何加速。</p>
<p>目前在VPS上，比较常用的加速软件有3钟：锐速、FinalSpeed、net-speeder</p>
<ol>
<li>锐速是国内某公司出的商业软件，不开源，网上流传有破解版可用，但是，它只支持KVM架构的VPS，而我的廉价搬瓦工是OpenVZ架构的，不支持。</li>
<li>FinalSpeed是开源的，项目地址：<a href="https://github.com/d1sm/finalspeed" title="Link to FinalSpeed" target="_blank" rel="external">FinalSpeed</a>，这个工具在使用时还需要装个客户端，否则没有任何加速效果，使用上不太方便。更关键的是，跑起来据说占用内存较大（可能因为是用JAVA开发的），作者特别提示搬瓦工至少需要256内存以上，而我的小VPS只有128M内存。</li>
<li>net-speeder也是开源的，项目地址：<a href="https://github.com/snooda/net-speeder" title="Link to net-speeder" target="_blank" rel="external">net-speeder</a>，这个项目是用C写的，代码非常简单，只有100多行，加速的原理简单粗暴，就是所有满足条件的包全部发2遍，这种做法有点损人利己，会占用更多带宽并使得流量翻倍，不过在高丢包高延迟环境下会比较有效。</li>
</ol>
<p>受VPS的限制，可选的加速工具只有net-speeder。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>目前在VPS上装的系统是Ubuntu 15.10，在Ubuntu下安装net-speeder还是比较简单的。</p>
<p>首先下载net-speeder的源码并解压，解压后有个路径net-speeder-master<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget https://github.com/snooda/net-speeder/archive/master.zip</span></span><br><span class="line"><span class="comment"># unzip master.zip</span></span><br><span class="line"><span class="comment"># cd net-speeder-master</span></span><br></pre></td></tr></table></figure></p>
<p>如果解压时提示unzip命令没找到，需要先安装unzip<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get install unzip</span></span><br></pre></td></tr></table></figure></p>
<p>准备编译的环境，安装几个依赖的包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-get install libnet1-dev</span></span><br><span class="line"><span class="comment"># apt-get install libpcap0.8-dev</span></span><br></pre></td></tr></table></figure></p>
<p>编译，因为VPS是OpenVZ架构的，需要加-DCOOKED参数，KVM的不用加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sh build.sh -DCOOKED</span></span><br></pre></td></tr></table></figure></p>
<p>编译后，当前目录下会有个net_speeder的可执行文件。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>执行net-speeder的命令格式：<code>./net_speeder 网卡名 加速规则（bpf规则）</code></p>
<p>网卡名可以用ifconfig命令看到，我的VPS上显示有2个网卡名：venet0 和 venet0:0，从IP地址看，后面一个绑定的是实际的VPS外网IP。</p>
<p>加速规则实际是个bpf规则，用来过滤哪些包需要发2遍，要了解更详细的bpf规则可以google一下。</p>
<p>项目的作者推荐的加速规则如下，重发所有的ip包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./net_speeder venet0:0 "ip"</span></span><br></pre></td></tr></table></figure></p>
<p>网上很多人推荐的加速规则如下，重发所有的tcp包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./net_speeder venet0:0 "tcp"</span></span><br></pre></td></tr></table></figure></p>
<p>但这两种规则范围还是太大了，尤其是作者推荐的，把所有的ip包全部发2遍，这么玩感觉有点耍流氓了。</p>
<p>而我的目的只需要给Shadowsocks加速，可以设定只加速Shadowsocks监听的端口，假设端口是8388，只加速这个端口的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./net_speeder venet0:0 "tcp src port 8388"</span></span><br></pre></td></tr></table></figure></p>
<p>假如需要给多个端口加速，命令可以写成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./net_speeder venet0:0 "tcp src port 8388 or port 8389"</span></span><br></pre></td></tr></table></figure></p>
<p>以后台方式执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nohup ./net_speeder venet0:0 "tcp src port 8388" &gt;/dev/null 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure></p>
<p>关闭net-speeder<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># killall net_speeder</span></span><br></pre></td></tr></table></figure></p>
<p>把这个工具加入开机启动，先拷贝到/usr/bin目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cp ./net_speeder /usr/bin</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'nohup /usr/bin/net_speeder venet0:0 "tcp src port 8388" &gt;/dev/null 2&gt;&amp;1 &amp;'</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>没详细测试加速前后下载等速度的差异，从youtube来看，效果还是非常明显的，youtube统计信息里的速度有了非常大的提升，缓存进度条跑的快了很多，一般视频都不会中断了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/markdown-angle-brackets/" itemprop="url">
                  在Markdown的正文中使用尖括号
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T15:33:32+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天用Markdown写一篇文章，里面用了一对尖括号，但在生成的网页中，却发现尖括号以及其中的内容均消失了，在尖括号前加反斜杠也无效，除非左尖括号后面跟的是中文。<br>以下是几种示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例1：&lt;not display&gt;</span><br><span class="line">例2：\&lt;not display\&gt;</span><br><span class="line">例3：&lt;中文可以显示&gt;</span><br></pre></td></tr></table></figure></p>
<p>显示为：<br>例1：<not display=""><br>例2：\<not display\=""><br>例3：&lt;中文可以显示&gt;</not></not></p>
<p>在网上查了一下，原来Markdown为了兼容HTML，将尖括号都认为是HTML的语法来处理了，即便加反斜杠也没用。</p>
<p>为解决这个问题，在正文中正常显示尖括号，可以用下面两种方式：</p>
<p>一种是作为行内代码处理，在尖括号对前后各加一个反引号 “`”，如这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例3：`&lt;display&gt;`</span><br></pre></td></tr></table></figure></p>
<p>显示为：<br>例3：<code>&lt;display&gt;</code></p>
<p>另一种是用转义字符来代替尖括号，左尖括号写<code>&amp;lt;</code>，右尖括号写<code>&amp;gt;</code>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例4：&amp;lt;display&amp;gt;</span><br></pre></td></tr></table></figure></p>
<p>显示为：<br>例4：&lt;display&gt;</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/debian-install-sudo/" itemprop="url">
                  Debian安装sudo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T11:28:09+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以前用Ubuntu时，sudo可以说是一个非常常用的命令，最近试用Debian，用非root用户登录，执行<code>sudo apt-get install ...</code>时，居然提示：sudo: command not found</p>
<p>然后用<code>dpkg -l|grep sudo</code>查看，发现默认就没有安装sudo，只能自己装了：</p>
<p>先su到root用户，然后执行 <code>apt-get install sudo</code></p>
<p>安装好后，执行 <code>visudo</code>，编辑允许使用sudo的用户，找到如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure></p>
<p>在下面新增一行，允许其他用户使用sudo，&lt;user&gt;是实际的用户名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;user&gt;   ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure></p>
<p>按Ctrl-O保存文件，注意默认保存的文件名是/etc/sudoers.tmp，需要把.tmp删除，直接保存为/etc/sudoers，会提示是否覆盖，选择Yes。<br>然后按Ctrl-X退出编辑。</p>
<p>也可以用vi直接编辑/etc/sudoers文件，这个文件是只读的，保存时需要用 :wq!</p>
<p>修改后，退出su，这样，其他用户就能使用sudo了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/git-sparse-checkout/" itemprop="url">
                  Git只获取部分目录的内容（稀疏检出）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T10:53:47+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>公司的开发从SVN切换到Git，在SVN下，可以很方便的只获取版本库中一个或多个目录的内容，但是Git的克隆，默认是直接拉取整个远程仓库，如果项目比较大，大量和自己无关的内容也会拉到本地，占用很多硬盘空间。</p>
<p>在网上搜了一下，Git在1.7版本后，已经支持只Checkout部分内容，这个功能叫做 sparse checkout（稀疏检出）。</p>
<h2 id="打开-sparse-checkout-功能"><a href="#打开-sparse-checkout-功能" class="headerlink" title="打开 sparse checkout 功能"></a>打开 sparse checkout 功能</h2><p>如果本地还没有建版本库，要用这个功能，先进入要放版本库的目录，在命令行执行几条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git init &lt;project&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;project&gt;</span><br><span class="line">$ git remote add origin ssh://&lt;user&gt;@&lt;repository<span class="string">'s url&gt;</span><br><span class="line">$ git config core.sparsecheckout true</span><br><span class="line">$ echo "path1/" &gt;&gt; .git/info/sparse-checkout</span><br><span class="line">$ echo "path2/" &gt;&gt; .git/info/sparse-checkout</span><br><span class="line">$ git pull origin master</span></span><br></pre></td></tr></table></figure></p>
<p>第一条命令<code>git init &lt;project&gt;</code>，先建立一个空的版本库，用实际的目录名替代<project>。<br>第二条命令<code>cd &lt;project&gt;</code>，进入创建的新的版本库的目录。<br>第三条命令<code>git remote add origin ssh://&lt;user&gt;@&lt;repository&#39;s url&gt;</code>，添加远程库的地址。<br>第四条命令<code>git config core.sparsecheckout true</code>，打开sparse checkout功能。<br>第五第六条命令<code>echo &quot;path1/&quot; &gt;&gt; .git/info/sparse-checkout</code>，添加2个目录到checkout的列表。路径是版本库下的相对路径，也可以用文本编辑器编辑这个文件。<br>第七条命令<code>git pull origin master</code>，拉取远程的 master 分支，也可以拉其他分支。</project></p>
<p>如果只拉取最近一次的变更，忽略以前的变更记录，在拉取时可以加参数depth，如<code>git pull --depth=1 origin master</code>  （浅克隆）</p>
<p>如果以后修改了 .git/info/sparse-checkout，增加或删除部分目录，可以执行如下命令重新Checkout<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></p>
<p>或执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">read</span>-tree -mu HEAD</span><br></pre></td></tr></table></figure></p>
<p>如果本地已经建了版本库，要使用这个功能，可以进入版本库的目录，执行以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config core.sparsecheckout <span class="literal">true</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"path1/"</span> &gt;&gt; .git/info/sparse-checkout</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"path2/"</span> &gt;&gt; .git/info/sparse-checkout</span><br><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></p>
<p>要关闭 sparse checkout功 能，仅仅修改设置，将core.sparsecheckout设为false是不生效的，需要修改 .git/info/sparse-checkout 文件，用一个”*“号替代其中的内容，然后执行 checkout 或 read-tree 命令。</p>
<h2 id="sparse-checkout-文件设置"><a href="#sparse-checkout-文件设置" class="headerlink" title="sparse-checkout 文件设置"></a>sparse-checkout 文件设置</h2><p>子目录的匹配<br>在 sparse-checkout 文件中，如果目录名称前带斜杠，如<code>/docs/</code>，将只匹配项目根目录下的docs目录，如果目录名称前不带斜杠，如<code>docs/</code>，其他目录下如果也有这个名称的目录，如<code>test/docs/</code>也能被匹配。<br>而如果写了多级目录，如<code>docs/05/</code>，则不管前面是否带有斜杠，都只匹配项目根目录下的目录，如<code>test/docs/05/</code>不能被匹配。</p>
<p>通配符 “*“ (星号)<br>在 sparse-checkout 文件中，支持通配符 “*“，如可以写成以下格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*docs/</span><br><span class="line">index.*</span><br><span class="line">*.gif</span><br></pre></td></tr></table></figure></p>
<p>排除项 “!” (感叹号)<br>在 sparse-checkout 文件中，也支持排除项 “!”，如只想排除排除项目下的 “docs” 目录，可以按如下格式写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">!/docs/</span><br></pre></td></tr></table></figure></p>
<p>要注意一点：如果要关闭sparsecheckout功能，全取整个项目库，可以写一个”*“号，但如果有排除项，必须写”/*“，同时排除项要写在通配符后面。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="匿名" />
          <p class="site-author-name" itemprop="name">匿名</p>
          <p class="site-description motion-element" itemprop="description">没有什么能够阻挡，你对自由的向往！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匿名</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
